------------------------------------------------------------------------------------------------------
PSEUDOCODE.txt

Author: Lauren Kimpel
TUID: tug60017@temple.edu
LAB: CIS3207 LAB02 - Creating a Linux Shell
TA: Jiacheng Shang


------------------------------------------------------------------------------------------------------
"internal.c"

This chunk of code will handle all internal functions.

void cls();
void quit();
void pause_a();
void echo();
void environ();
void dir();
int cd();
void help();

void cls(){

//sketchy code that prints 100 new lines to give the appearance
of a cleared screen.\

   for (int i = 0; i<100; i++){
       puts("");
   }

}


void quit(){
     exit(0);
}

void pause_a(){

     char ENTER ='\n';
     char input;

     while(1){
     scan(input)
     if (input== ENTER){
     break;	 
     }
     }
     }

void echo(char *input){
     printf(input);	
}

void environ(char **env){
     int index = 0;
     while (env[index]!=NULL){
     	   printf(env[index]);
     	   index++;
     }
}

void dir(char *argv){
DIR *d;
struct dirent dir;

if (argv == ""){
opendir("");
}

else
{

opendir(argv);

}

if (success){
while(readdir(d) != NULL){
printf(dirname);
}
closedir(d);

}else{
puts("an error occurred.");

}
}

int cd(char *argv){

char *buffer = malloc(path_max);
char *resolved_path = real[ath(argv, buffer);
char pwd = getenv("PWD");

if (resolved_path == true){
strcpy(pwd, resolved_path);
}
else{
puts("error");
}

int new_dir = chdir(pwd);
if (chdir(resolved_path)!=0){
puts("directory might not exist!");
}
return new_dir;
}

------------------------------------------------------------------------------------------------------

"main.c"


This chunk of code will attempt to describe the main function's basic operation.


void function_start();
int str_process();

int main(){

function_start();

}


void function_start(){

//This could describe an initial state for no reason other than organizational purposes.
It may not exist when the lab is rewritten.

scanf(char *user input, char **some_string);

//we should tokenize each string and check for errors

str_process(some_string);

if (str_process(some_string) == 0){
//if command is successful
handle_command(some_string);

}else{
printf("Error parsing string!");
}

}


int handle_command(){

//check for pipes and redirects
//check for internal commands within the string
//then check for external commands

//THIS PART ASSUMES THAT THERE ARE NO ILLEGAL COMMANDS ATTACHED
//THAT FUNCTIONALITY IS DEALT WITH IN str_process(some_string)!!!!!!!!!!!!!!

int index;
while(some_string[index]!=NULL){

if (">" || "<" || "|"){
       handle_redirect(some_string[i], int fd1, fd2, ...., fdn);
       }
    if ("ls args"){
       ls(args);
       }
    if ("cls"){
       cls();
       }
    if ("pause_a"){
       pause_a();
       }
    if ("echo args"){
       echo(args);
       }
    if ("environ"){
       environ(env);
       }
    if ("dir args"){
       dir(args);
       }
    if ("cd args"){
       cd(args);
       }
    if ("help args"){
       help(args);
       }


}

index++;

}


void handle_redirect(some_string[i], int fd){

in order to handle infinite pipes, that means this section will need to
take recusrion into account.
Luckily, that functionality is going to be stored elsewhere, this method will just be calling
those methods.
The purpose of this method is to abstract some of the piping. It may be completely useless though.
















}
